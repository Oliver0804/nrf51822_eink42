
#include <zephyr/types.h>
#include <stddef.h>
#include <string.h>
#include <errno.h>
#include <zephyr/sys/printk.h>
#include <zephyr/sys/byteorder.h>

#include <zephyr/drivers/spi.h>

#include <zephyr/kernel.h>

#include "epaper.h"

#include "picture.h"
#include "imagedata.h"
int width = EPD_WIDTH;
int height = EPD_HEIGHT;
const unsigned char lut_vcom0[] =
    {
        0x00,
        0x08,
        0x08,
        0x00,
        0x00,
        0x02,
        0x00,
        0x0F,
        0x0F,
        0x00,
        0x00,
        0x01,
        0x00,
        0x08,
        0x08,
        0x00,
        0x00,
        0x02,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,

};
const unsigned char lut_ww[] = {
    0x50,
    0x08,
    0x08,
    0x00,
    0x00,
    0x02,
    0x90,
    0x0F,
    0x0F,
    0x00,
    0x00,
    0x01,
    0xA0,
    0x08,
    0x08,
    0x00,
    0x00,
    0x02,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,

};
const unsigned char lut_bw[] = {
    0x50,
    0x08,
    0x08,
    0x00,
    0x00,
    0x02,
    0x90,
    0x0F,
    0x0F,
    0x00,
    0x00,
    0x01,
    0xA0,
    0x08,
    0x08,
    0x00,
    0x00,
    0x02,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,

};

const unsigned char lut_bb[] = {
    0xA0,
    0x08,
    0x08,
    0x00,
    0x00,
    0x02,
    0x90,
    0x0F,
    0x0F,
    0x00,
    0x00,
    0x01,
    0x50,
    0x08,
    0x08,
    0x00,
    0x00,
    0x02,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,

};

const unsigned char lut_wb[] = {
    0x20,
    0x08,
    0x08,
    0x00,
    0x00,
    0x02,
    0x90,
    0x0F,
    0x0F,
    0x00,
    0x00,
    0x01,
    0x10,
    0x08,
    0x08,
    0x00,
    0x00,
    0x02,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,

};

/******************************gray*********************************/
// 0~3 gray
const unsigned char EPD_4IN2_4Gray_lut_vcom[] =
    {
        0x00, 0x0A, 0x00, 0x00, 0x00, 0x01,
        0x60, 0x14, 0x14, 0x00, 0x00, 0x01,
        0x00, 0x14, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x13, 0x0A, 0x01, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00

};
// R21
const unsigned char EPD_4IN2_4Gray_lut_ww[] = {
    0x40,
    0x0A,
    0x00,
    0x00,
    0x00,
    0x01,
    0x90,
    0x14,
    0x14,
    0x00,
    0x00,
    0x01,
    0x10,
    0x14,
    0x0A,
    0x00,
    0x00,
    0x01,
    0xA0,
    0x13,
    0x01,
    0x00,
    0x00,
    0x01,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
};
// R22H	r
const unsigned char EPD_4IN2_4Gray_lut_bw[] = {
    0x40,
    0x0A,
    0x00,
    0x00,
    0x00,
    0x01,
    0x90,
    0x14,
    0x14,
    0x00,
    0x00,
    0x01,
    0x00,
    0x14,
    0x0A,
    0x00,
    0x00,
    0x01,
    0x99,
    0x0C,
    0x01,
    0x03,
    0x04,
    0x01,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
};
// R23H	w
const unsigned char EPD_4IN2_4Gray_lut_wb[] = {
    0x40,
    0x0A,
    0x00,
    0x00,
    0x00,
    0x01,
    0x90,
    0x14,
    0x14,
    0x00,
    0x00,
    0x01,
    0x00,
    0x14,
    0x0A,
    0x00,
    0x00,
    0x01,
    0x99,
    0x0B,
    0x04,
    0x04,
    0x01,
    0x01,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
};
// R24H	b
const unsigned char EPD_4IN2_4Gray_lut_bb[] = {
    0x80,
    0x0A,
    0x00,
    0x00,
    0x00,
    0x01,
    0x90,
    0x14,
    0x14,
    0x00,
    0x00,
    0x01,
    0x20,
    0x14,
    0x0A,
    0x00,
    0x00,
    0x01,
    0x50,
    0x13,
    0x01,
    0x00,
    0x00,
    0x01,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
};
const struct device *spi_dev = DEVICE_DT_GET(SPI_BUS);

const struct spi_config spi_cfg = {
    .frequency = 1000000U,
    .operation = SPI_WORD_SET(8) | SPI_TRANSFER_MSB | SPI_OP_MODE_MASTER};

void Epaper_Spi_WriteByte(uint8_t TxData)
{
    /* unsigned char TempData;
    unsigned char scnt;
    TempData=TxData;

  EPD_W21_CLK_0;
    for(scnt=0;scnt<8;scnt++)
    {
        if(TempData&0x80)
          EPD_W21_MOSI_1 ;
        else
          EPD_W21_MOSI_0 ;
        EPD_W21_CLK_1;
      EPD_W21_CLK_0;
        TempData=TempData<<1;

  } */
    struct spi_buf bufs[] = {
        {.buf = &TxData,
         .len = 1},
    };

    struct spi_buf_set tx = {
        .buffers = bufs,
        .count = 1};

    spi_write(spi_dev, &spi_cfg, &tx);
}

void Epaper_READBUSY(void)
{
    while (1)
    { //=1 BUSY
        if (isEPD_W21_BUSY == 1)
        {
            printk("0");
            break;
        }
    }
}

void Epaper_Write_Command(uint8_t cmd)
{
    EPD_W21_CS_1;
    EPD_W21_CS_0;
    EPD_W21_DC_0; // D/C#   0:command  1:data

    Epaper_Spi_WriteByte(cmd);
    EPD_W21_CS_1;
}

void Epaper_Write_Data(uint8_t data)
{
    EPD_W21_CS_1;
    EPD_W21_CS_0;
    EPD_W21_DC_1; // D/C#   0:command  1:data

    Epaper_Spi_WriteByte(data);
    EPD_W21_CS_1;
}

/////////////////////////////////////////////////////////////////////
void EPD_Reset()
{
    EPD_W21_RST_0
    k_msleep(2);
    EPD_W21_RST_1;

    k_msleep(20);
    EPD_W21_RST_0
    k_msleep(2);
    EPD_W21_RST_1;

    k_msleep(20);
    EPD_W21_RST_0
    k_msleep(2);
    EPD_W21_RST_1;

    k_msleep(20);
    EPD_W21_RST_1;
}

void EPD_SetLut()
{
    unsigned int count;
    Epaper_Write_Command(LUT_FOR_VCOM); // vcom
    for (count = 0; count < 36; count++)
    {
        Epaper_Write_Data(lut_vcom0[count]);
    }

    Epaper_Write_Command(LUT_WHITE_TO_WHITE); // ww --
    for (count = 0; count < 36; count++)
    {
        Epaper_Write_Data(lut_ww[count]);
    }

    Epaper_Write_Command(LUT_BLACK_TO_WHITE); // bw r
    for (count = 0; count < 36; count++)
    {
        Epaper_Write_Data(lut_bw[count]);
    }

    Epaper_Write_Command(LUT_WHITE_TO_BLACK); // wb w
    for (count = 0; count < 36; count++)
    {
        Epaper_Write_Data(lut_bb[count]);
    }

    Epaper_Write_Command(LUT_BLACK_TO_BLACK); // bb b
    for (count = 0; count < 36; count++)
    {
        Epaper_Write_Data(lut_wb[count]);
    }
}
void EPD_ClearFrame(void)
{

    Epaper_Write_Command(RESOLUTION_SETTING);
    Epaper_Write_Data(width >> 8);
    Epaper_Write_Data(width & 0xff);
    Epaper_Write_Data(height >> 8);
    Epaper_Write_Data(height & 0xff);

    Epaper_Write_Command(DATA_START_TRANSMISSION_1);
    k_msleep(2);
    for (int i = 0; i < width / 8 * height; i++)
    {
        Epaper_Write_Data(0xFF);
    }
    k_msleep(2);
    Epaper_Write_Command(DATA_START_TRANSMISSION_2);
    k_msleep(2);
    for (int i = 0; i < width / 8 * height; i++)
    {
        Epaper_Write_Data(0xFF);
    }
    k_msleep(2);
}
void EPD_DisplayFrame(void)
{

    Epaper_Write_Command(RESOLUTION_SETTING);
    Epaper_Write_Data(width >> 8);
    Epaper_Write_Data(width & 0xff);
    Epaper_Write_Data(height >> 8);
    Epaper_Write_Data(height & 0xff);

    Epaper_Write_Command(VCM_DC_SETTING);
    Epaper_Write_Data(0x12);

    Epaper_Write_Command(VCOM_AND_DATA_INTERVAL_SETTING);
    Epaper_Write_Command(0x97); // VBDF 17|D7 VBDW 97  VBDB 57  VBDF F7  VBDW 77  VBDB 37  VBDR B7

    Epaper_Write_Command(DATA_START_TRANSMISSION_1);
    for (int i = 0; i < width / 8 * height; i++)
    {
        Epaper_Write_Data(0xFF); // bit set: white, bit reset: black
    }
    k_msleep(2);
    Epaper_Write_Command(DATA_START_TRANSMISSION_2);
    for (int i = 0; i < width / 8 * height; i++)
    {
        Epaper_Write_Data(0xFF); // bit set: white, bit reset: black
    }
    k_msleep(2);

    Epaper_Write_Command(0x12);
    k_msleep(100);
    Epaper_READBUSY();
}
void EPD_DisplayFrame_Image(const uint8_t *frame_buffer)
{

    // 設定電子紙解析度
    Epaper_Write_Command(RESOLUTION_SETTING);
    Epaper_Write_Data(width >> 8);    // 寬度高位元組
    Epaper_Write_Data(width & 0xFF);  // 寬度低位元組
    Epaper_Write_Data(height >> 8);   // 高度高位元組
    Epaper_Write_Data(height & 0xFF); // 高度低位元組

    // VCOM 和 DC 設定
    Epaper_Write_Command(VCM_DC_SETTING);
    Epaper_Write_Data(0x12);

    Epaper_Write_Command(VCOM_AND_DATA_INTERVAL_SETTING);
    Epaper_Write_Command(0x97); // 依據數據手冊設定

    if (frame_buffer != NULL)
    {
        // 傳輸第一層影像資料
        Epaper_Write_Command(DATA_START_TRANSMISSION_1);
        for (int i = 0; i < (width / 8) * height; i++)
        {
            Epaper_Write_Data(0xFF); // 清除，顯示全白
        }
        k_msleep(2);

        // 傳輸第二層影像資料
        Epaper_Write_Command(DATA_START_TRANSMISSION_2);
        for (int i = 0; i < (width / 8) * height; i++)
        {
            // 從影像緩衝區讀取數據
            Epaper_Write_Data(frame_buffer[i]);
        }
        k_msleep(2);
    }

    // 刷新顯示
    Epaper_Write_Command(0x12);
    k_msleep(100);

    // 等待顯示完成
    Epaper_READBUSY();
}
void EPD_HW_Init(void)
{
    printk("EPD_HW_Init\n");
    int ret = gpio_pin_set_dt(&edp_res_pin, 0);
    if (ret < 0)
    {
        printk("Error setting reset pin low\n");
    }
    else
    {
        printk("Reset pin set low\n");
    }
    EPD_Reset();
    Epaper_Write_Command(0x06);
    Epaper_Write_Data(0x17);
    Epaper_Write_Data(0x17);
    Epaper_Write_Data(0x17);

    Epaper_Write_Command(0x04);
    Epaper_Write_Command(0x17);
    Epaper_Write_Data(0x16);

    Epaper_Write_Command(0x01);
    Epaper_Write_Data(0x03); // VDS_EN, VDG_EN
    Epaper_Write_Data(0x00); // VCOM_HV, VGHL_LV[1], VGHL_LV[0]
    Epaper_Write_Data(0x2b); // VDH
    Epaper_Write_Data(0x2b); // VDL

    Epaper_Write_Command(0x06);
    Epaper_Write_Data(0x17);
    Epaper_Write_Data(0x17);
    Epaper_Write_Data(0x17); // 07 0f 17 1f 27 2F 37 2f
    Epaper_Write_Command(0x04);
    Epaper_READBUSY();
    Epaper_Write_Command(0x00);
    Epaper_Write_Data(0xbf); // KW-BF   KWR-AF  BWROTP 0f

    Epaper_Write_Command(0x30);
    Epaper_Write_Data(0x3c); // 3A 100HZ   29 150Hz 39 200HZ  31 171HZ

    Epaper_Write_Command(0x61); // resolution setting
    Epaper_Write_Data(0x01);
    Epaper_Write_Data(0x90); // 128
    Epaper_Write_Data(0x01); //
    Epaper_Write_Data(0x2c);

    Epaper_Write_Command(0x82); // vcom_DC setting
    Epaper_Write_Data(0x12);

    Epaper_Write_Command(0X50); // VCOM AND DATA INTERVAL SETTING
    Epaper_Write_Data(0x97);    // 97white border 77black border    VBDF 17|D7 VBDW 97 VBDB 57    VBDF F7 VBDW 77 VBDB 37  VBDR B7

    EPD_SetLut();
}
/////////////////////////////////////////////////////////////////////////////////////////
/*When the electronic paper screen is updated, do not unplug the electronic paper to avoid damage to the screen*/

void EPD_Update(void)
{
    Epaper_Write_Command(0x22); // Display Update Control
    Epaper_Write_Data(0xF7);
    Epaper_Write_Command(0x20); // Activate Display Update Sequence
    Epaper_READBUSY();
}
/*When the electronic paper screen is updated, do not unplug the electronic paper to avoid damage to the screen*/
void EPD_Part_Update(void)
{
    Epaper_Write_Command(0x22); // Display Update Control
    Epaper_Write_Data(0xFF);
    Epaper_Write_Command(0x20); // Activate Display Update Sequence
    Epaper_READBUSY();
}
//////////////////////////////All screen update////////////////////////////////////////////
void EPD_WhiteScreen_ALL(const unsigned char *datas)
{
    unsigned int i;
    Epaper_Write_Command(0x24); // write RAM for black(0)/white (1)
    for (i = 0; i < ALLSCREEN_GRAGHBYTES; i++)
    {
        Epaper_Write_Data(*datas);
        datas++;
    }
    EPD_Update();
}
///////////////////////////Part update//////////////////////////////////////////////
// The x axis is reduced by one byte, and the y axis is reduced by one pixel.
void EPD_SetRAMValue_BaseMap(const unsigned char *datas)
{
    unsigned int i;
    const unsigned char *datas_flag;
    datas_flag = datas;

    Epaper_Write_Command(0x24); // Write Black and White image to RAM
    for (i = 0; i < ALLSCREEN_GRAGHBYTES; i++)
    {
        Epaper_Write_Data(*datas);
        datas++;
    }
    datas = datas_flag;
    Epaper_Write_Command(0x26); // Write Black and White image to RAM
    for (i = 0; i < ALLSCREEN_GRAGHBYTES; i++)
    {
        Epaper_Write_Data(*datas);
        datas++;
    }
    EPD_Update();
}
void EPD_Dis_Part(unsigned int x_start, unsigned int y_start, const unsigned char *datas, unsigned int PART_COLUMN, unsigned int PART_LINE)
{
    unsigned int i;
    unsigned int x_end, y_start1, y_start2, y_end1, y_end2;
    x_start = x_start / 8;
    x_end = x_start + PART_LINE / 8 - 1;

    y_start1 = 0;
    y_start2 = y_start;
    if (y_start >= 256)
    {
        y_start1 = y_start2 / 256;
        y_start2 = y_start2 % 256;
    }
    y_end1 = 0;
    y_end2 = y_start + PART_COLUMN - 1;
    if (y_end2 >= 256)
    {
        y_end1 = y_end2 / 256;
        y_end2 = y_end2 % 256;
    }

    Epaper_Write_Command(0x44);  // set RAM x address start/end, in page 35
    Epaper_Write_Data(x_start);  // RAM x address start at 00h;
    Epaper_Write_Data(x_end);    // RAM x address end at 0fh(15+1)*8->128
    Epaper_Write_Command(0x45);  // set RAM y address start/end, in page 35
    Epaper_Write_Data(y_start2); // RAM y address start at 0127h;
    Epaper_Write_Data(y_start1); // RAM y address start at 0127h;
    Epaper_Write_Data(y_end2);   // RAM y address end at 00h;
    Epaper_Write_Data(y_end1);   // ????=0

    Epaper_Write_Command(0x4E); // set RAM x address count to 0;
    Epaper_Write_Data(x_start);
    Epaper_Write_Command(0x4F); // set RAM y address count to 0X127;
    Epaper_Write_Data(y_start2);
    Epaper_Write_Data(y_start1);

    Epaper_Write_Command(0x24); // Write Black and White image to RAM
    for (i = 0; i < PART_COLUMN * PART_LINE / 8; i++)
    {
        Epaper_Write_Data(*datas);
        datas++;
    }
    EPD_Part_Update();
}

void EPD_DeepSleep(void)
{
    Epaper_Write_Command(0x10); // enter deep sleep
    Epaper_Write_Data(0x01);
    k_msleep(100);
}
void EPD_Sleep(void)
{
    Epaper_Write_Command(VCOM_AND_DATA_INTERVAL_SETTING);
    Epaper_Write_Data(0x17);              // border floating
    Epaper_Write_Command(VCM_DC_SETTING); // VCOM to 0V
    Epaper_Write_Command(PANEL_SETTING);
    k_msleep(100);

    Epaper_Write_Command(POWER_SETTING); // VG&VS to 0V fast
    Epaper_Write_Data(0x00);
    Epaper_Write_Data(0x00);
    Epaper_Write_Data(0x00);
    Epaper_Write_Data(0x00);
    Epaper_Write_Data(0x00);
    k_msleep(100);

    Epaper_Write_Command(POWER_OFF); // power off
    Epaper_READBUSY();
    Epaper_Write_Command(DEEP_SLEEP); // deep sleep
    Epaper_Write_Data(0xA5);
}

/////////////////////////////////Single display////////////////////////////////////////////////

void EPD_WhiteScreen_White(void)

{
    unsigned int i, k;
    Epaper_Write_Command(0x24); // write RAM for black(0)/white (1)
    for (k = 0; k < 250; k++)
    {
        for (i = 0; i < 25; i++)
        {
            Epaper_Write_Data(0xff);
        }
    }
    EPD_Update();
}

/////////////////////////////////////TIME///////////////////////////////////////////////////
void EPD_Dis_Part_myself(unsigned int x_startA, unsigned int y_startA, const unsigned char *datasA,
                         unsigned int x_startB, unsigned int y_startB, const unsigned char *datasB,
                         unsigned int x_startC, unsigned int y_startC, const unsigned char *datasC,
                         unsigned int x_startD, unsigned int y_startD, const unsigned char *datasD,
                         unsigned int x_startE, unsigned int y_startE, const unsigned char *datasE,
                         unsigned int PART_COLUMN, unsigned int PART_LINE)
{
    unsigned int i;
    unsigned int x_end, y_start1, y_start2, y_end1, y_end2;

    // Data A////////////////////////////
    x_startA = x_startA / 8; // Convert to byte
    x_end = x_startA + PART_LINE / 8 - 1;

    y_start1 = 0;
    y_start2 = y_startA - 1;
    if (y_startA >= 256)
    {
        y_start1 = y_start2 / 256;
        y_start2 = y_start2 % 256;
    }
    y_end1 = 0;
    y_end2 = y_startA + PART_COLUMN - 1;
    if (y_end2 >= 256)
    {
        y_end1 = y_end2 / 256;
        y_end2 = y_end2 % 256;
    }

    Epaper_Write_Command(0x44);  // set RAM x address start/end, in page 35
    Epaper_Write_Data(x_startA); // RAM x address start at 00h;
    Epaper_Write_Data(x_end);    // RAM x address end at 0fh(15+1)*8->128
    Epaper_Write_Command(0x45);  // set RAM y address start/end, in page 35
    Epaper_Write_Data(y_start2); // RAM y address start at 0127h;
    Epaper_Write_Data(y_start1); // RAM y address start at 0127h;
    Epaper_Write_Data(y_end2);   // RAM y address end at 00h;
    Epaper_Write_Data(y_end1);

    Epaper_Write_Command(0x4E); // set RAM x address count to 0;
    Epaper_Write_Data(x_startA);
    Epaper_Write_Command(0x4F); // set RAM y address count to 0X127;
    Epaper_Write_Data(y_start2);
    Epaper_Write_Data(y_start1);

    Epaper_Write_Command(0x24); // Write Black and White image to RAM
    for (i = 0; i < PART_COLUMN * PART_LINE / 8; i++)
    {
        Epaper_Write_Data(*datasA);
        datasA++;
    }
    // Data B/////////////////////////////////////
    x_startB = x_startB / 8; // Convert to byte
    x_end = x_startB + PART_LINE / 8 - 1;

    y_start1 = 0;
    y_start2 = y_startB - 1;
    if (y_startB >= 256)
    {
        y_start1 = y_start2 / 256;
        y_start2 = y_start2 % 256;
    }
    y_end1 = 0;
    y_end2 = y_startB + PART_COLUMN - 1;
    if (y_end2 >= 256)
    {
        y_end1 = y_end2 / 256;
        y_end2 = y_end2 % 256;
    }

    Epaper_Write_Command(0x44);  // set RAM x address start/end, in page 35
    Epaper_Write_Data(x_startB); // RAM x address start at 00h;
    Epaper_Write_Data(x_end);    // RAM x address end at 0fh(15+1)*8->128
    Epaper_Write_Command(0x45);  // set RAM y address start/end, in page 35
    Epaper_Write_Data(y_start2); // RAM y address start at 0127h;
    Epaper_Write_Data(y_start1); // RAM y address start at 0127h;
    Epaper_Write_Data(y_end2);   // RAM y address end at 00h;
    Epaper_Write_Data(y_end1);

    Epaper_Write_Command(0x4E); // set RAM x address count to 0;
    Epaper_Write_Data(x_startB);
    Epaper_Write_Command(0x4F); // set RAM y address count to 0X127;
    Epaper_Write_Data(y_start2);
    Epaper_Write_Data(y_start1);

    Epaper_Write_Command(0x24); // Write Black and White image to RAM
    for (i = 0; i < PART_COLUMN * PART_LINE / 8; i++)
    {
        Epaper_Write_Data(*datasB);
        datasB++;
    }

    // Data C//////////////////////////////////////
    x_startC = x_startC / 8; // Convert to byte
    x_end = x_startC + PART_LINE / 8 - 1;

    y_start1 = 0;
    y_start2 = y_startC - 1;
    if (y_startC >= 256)
    {
        y_start1 = y_start2 / 256;
        y_start2 = y_start2 % 256;
    }
    y_end1 = 0;
    y_end2 = y_startC + PART_COLUMN - 1;
    if (y_end2 >= 256)
    {
        y_end1 = y_end2 / 256;
        y_end2 = y_end2 % 256;
    }

    Epaper_Write_Command(0x44);  // set RAM x address start/end, in page 35
    Epaper_Write_Data(x_startC); // RAM x address start at 00h;
    Epaper_Write_Data(x_end);    // RAM x address end at 0fh(15+1)*8->128
    Epaper_Write_Command(0x45);  // set RAM y address start/end, in page 35
    Epaper_Write_Data(y_start2); // RAM y address start at 0127h;
    Epaper_Write_Data(y_start1); // RAM y address start at 0127h;
    Epaper_Write_Data(y_end2);   // RAM y address end at 00h;
    Epaper_Write_Data(y_end1);

    Epaper_Write_Command(0x4E); // set RAM x address count to 0;
    Epaper_Write_Data(x_startC);
    Epaper_Write_Command(0x4F); // set RAM y address count to 0X127;
    Epaper_Write_Data(y_start2);
    Epaper_Write_Data(y_start1);

    Epaper_Write_Command(0x24); // Write Black and White image to RAM
    for (i = 0; i < PART_COLUMN * PART_LINE / 8; i++)
    {
        Epaper_Write_Data(*datasC);
        datasC++;
    }

    // Data D//////////////////////////////////////
    x_startD = x_startD / 8; // Convert to byte
    x_end = x_startD + PART_LINE / 8 - 1;

    y_start1 = 0;
    y_start2 = y_startD - 1;
    if (y_startD >= 256)
    {
        y_start1 = y_start2 / 256;
        y_start2 = y_start2 % 256;
    }
    y_end1 = 0;
    y_end2 = y_startD + PART_COLUMN - 1;
    if (y_end2 >= 256)
    {
        y_end1 = y_end2 / 256;
        y_end2 = y_end2 % 256;
    }

    Epaper_Write_Command(0x44);  // set RAM x address start/end, in page 35
    Epaper_Write_Data(x_startD); // RAM x address start at 00h;
    Epaper_Write_Data(x_end);    // RAM x address end at 0fh(15+1)*8->128
    Epaper_Write_Command(0x45);  // set RAM y address start/end, in page 35
    Epaper_Write_Data(y_start2); // RAM y address start at 0127h;
    Epaper_Write_Data(y_start1); // RAM y address start at 0127h;
    Epaper_Write_Data(y_end2);   // RAM y address end at 00h;
    Epaper_Write_Data(y_end1);

    Epaper_Write_Command(0x4E); // set RAM x address count to 0;
    Epaper_Write_Data(x_startD);
    Epaper_Write_Command(0x4F); // set RAM y address count to 0X127;
    Epaper_Write_Data(y_start2);
    Epaper_Write_Data(y_start1);

    Epaper_Write_Command(0x24); // Write Black and White image to RAM
    for (i = 0; i < PART_COLUMN * PART_LINE / 8; i++)
    {
        Epaper_Write_Data(*datasD);
        datasD++;
    }
    // Data E//////////////////////////////////////
    x_startE = x_startE / 8; // Convert to byte
    x_end = x_startE + PART_LINE / 8 - 1;

    y_start1 = 0;
    y_start2 = y_startE - 1;
    if (y_startE >= 256)
    {
        y_start1 = y_start2 / 256;
        y_start2 = y_start2 % 256;
    }
    y_end1 = 0;
    y_end2 = y_startE + PART_COLUMN - 1;
    if (y_end2 >= 256)
    {
        y_end1 = y_end2 / 256;
        y_end2 = y_end2 % 256;
    }

    Epaper_Write_Command(0x44);  // set RAM x address start/end, in page 35
    Epaper_Write_Data(x_startE); // RAM x address start at 00h;
    Epaper_Write_Data(x_end);    // RAM x address end at 0fh(15+1)*8->128
    Epaper_Write_Command(0x45);  // set RAM y address start/end, in page 35
    Epaper_Write_Data(y_start2); // RAM y address start at 0127h;
    Epaper_Write_Data(y_start1); // RAM y address start at 0127h;
    Epaper_Write_Data(y_end2);   // RAM y address end at 00h;
    Epaper_Write_Data(y_end1);

    Epaper_Write_Command(0x4E); // set RAM x address count to 0;
    Epaper_Write_Data(x_startE);
    Epaper_Write_Command(0x4F); // set RAM y address count to 0X127;
    Epaper_Write_Data(y_start2);
    Epaper_Write_Data(y_start1);

    Epaper_Write_Command(0x24); // Write Black and White image to RAM
    for (i = 0; i < PART_COLUMN * PART_LINE / 8; i++)
    {
        Epaper_Write_Data(*datasE);
        datasE++;
    }
    EPD_Part_Update();
}

//////////////////////////////////////////////////////////////////////////////////////

void gpio_init()
{
    if (!device_is_ready(edp_cs_pin.port) && !device_is_ready(edp_dc_pin.port) && !device_is_ready(edp_res_pin.port) && !device_is_ready(edp_busy_pin.port))
    {
        printk("GPIO port initialization error\n");
        return;
    }
    int ret;
    ret = gpio_pin_configure_dt(&edp_cs_pin, GPIO_OUTPUT_ACTIVE);
    if (ret < 0)
    {
        return;
    }
    ret = gpio_pin_configure_dt(&edp_dc_pin, GPIO_OUTPUT_ACTIVE);
    if (ret < 0)
    {
        return;
    }
    ret = gpio_pin_configure_dt(&edp_res_pin, GPIO_OUTPUT_ACTIVE);
    if (ret < 0)
    {
        return;
    }
    ret = gpio_pin_configure_dt(&edp_busy_pin, GPIO_INPUT | GPIO_PULL_UP);
    if (ret < 0)
    {
        return;
    }

    printk("GPIO pins initialized correctly\n");
    ret = gpio_pin_set_dt(&edp_res_pin, 0);
    printk("pin reset low: %d\n", ret);
}

void main(void)
{
    unsigned char fen_L, fen_H, miao_L, miao_H;
    gpio_init();
    printk("GPIO pins initialized correctly\n");
    printk("EPD_HW_Init\n");

    while (1)
    {
        // Full screen refresh
        EPD_HW_Init(); // Electronic paper initialization

        printk("Full screen refresh\n");
        EPD_ClearFrame();
        EPD_DisplayFrame_Image(epd_bitmap_images_blackcat);
        EPD_Sleep();
        k_msleep(5000);
    }
    ///////////////////////////////////////////////////////////
}

代碼如何將main.c進行優化拆解成多個.c文件